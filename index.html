<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Морской бой — обновлённый (фикс перемещения и привязки)</title>
<style>
:root{ --cell-size:48px; --accent:#1fb6ff; --gap:3px; }
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#02111a,#042033);color:#eaf6ff;font-family:Inter,Segoe UI,Arial}
.container{max-width:1100px;margin:12px auto;padding:12px}
.header{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px}
.title{font-size:20px;font-weight:700}
.layout{display:flex;gap:12px;align-items:flex-start}
.col-left{flex:1}
.col-right{width:320px;min-width:240px}
.card{background:rgba(255,255,255,0.03);padding:12px;border-radius:10px;margin-bottom:12px}
.menu-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.btn{background:var(--accent);color:#002;border:0;padding:8px 12px;border-radius:8px;font-weight:700;cursor:pointer}
.btn.ghost{background:transparent;color:#cfeeff;border:1px solid rgba(255,255,255,0.06)}
.boards{display:flex;gap:12px;flex-wrap:wrap}
.board-wrap{position:relative;background:rgba(255,255,255,0.02);padding:16px;border-radius:10px}
.label-top{position:absolute;top:10px;left:64px;right:12px;display:flex;gap:4px;pointer-events:none}
.label-left{position:absolute;left:10px;top:64px;bottom:12px;display:flex;flex-direction:column;gap:4px;pointer-events:none;align-items:flex-end}
.board{display:grid;background:linear-gradient(180deg,#063241,#042f2b);border-radius:6px;overflow:visible;position:relative}
.board{grid-template-columns: repeat(10, var(--cell-size)); grid-template-rows: repeat(10, var(--cell-size)); gap:var(--gap)}
.cell{width:var(--cell-size);height:var(--cell-size);border-radius:6px;background:linear-gradient(180deg,#083a44,#052f30);border:1px solid rgba(255,255,255,0.04);position:relative;overflow:hidden}
.cell.valid{box-shadow:0 0 0 3px rgba(0,200,0,0.18) inset}
.cell.invalid{box-shadow:0 0 0 3px rgba(200,0,0,0.18) inset}
.cell.occupied{background-color:transparent}
.cell.hit{background-size:cover;background-position:center}
.cell.miss{background-size:cover;background-position:center;opacity:0.95}
.placed-ship{position:absolute;pointer-events:auto;background-repeat:no-repeat;background-position:center;z-index:30;cursor:grab;display:flex;align-items:center;justify-content:center}
.placed-ship img{width:100%;height:100%;object-fit:contain;pointer-events:none;user-drag:none;user-select:none}
.panel{background:rgba(255,255,255,0.03);padding:12px;border-radius:10px}
.ship-list{display:flex;flex-direction:column;gap:8px}
.ship-item{display:flex;align-items:center;gap:12px;padding:8px;border-radius:8px;background:linear-gradient(90deg,#123240,#0f2a33);cursor:grab}
.preview{width:72px;height:38px;background-size:contain;background-position:center;background-repeat:no-repeat;border-radius:6px;background-color:rgba(255,255,255,0.02)}
.meta{flex:1}
.controls{display:flex;gap:8px;align-items:center;margin-top:8px}
.icon-btn{width:40px;height:36px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.04);display:inline-flex;align-items:center;justify-content:center;cursor:pointer}
.rotate-float{position:fixed;z-index:2000;display:flex;gap:6px;pointer-events:auto}
.overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:2000;pointer-events:none;opacity:0;transition:opacity .2s}
.overlay.show{pointer-events:all;opacity:1}
.overlay .panel{background:rgba(0,0,0,0.7);padding:20px;border-radius:12px;text-align:center;color:#fff}
.confetti-root{position:fixed;inset:0;pointer-events:none;z-index:1500}
@media(max-width:860px){.layout{flex-direction:column}.col-right{width:100%}.label-top{left:56px}.label-left{left:8px}}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div>
      <div class="title">Морской бой — обновлённый</div>
      <div class="subtitle small">Перетаскивайте корабль из панели на поле или перемещайте уже установленные.</div>
    </div>
    <div>
      <button class="btn" id="startScreenBtn">Главный экран</button>
    </div>
  </div>

  <div class="layout">
    <div class="col-left">
      <div class="card" id="menuCard">
        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between">
          <div style="font-weight:700">Режим</div>
          <div class="menu-row">
            <button class="btn" id="modeBotBtn">Против бота</button>
            <button class="btn ghost" id="modePlayerBtn" disabled>Против игрока (выкл)</button>
          </div>
        </div>

        <div style="margin-top:10px;display:flex;align-items:center;justify-content:space-between">
          <div style="font-weight:700">Сложность</div>
          <div class="menu-row">
            <button class="btn ghost" data-diff="easy">Лёгкая</button>
            <button class="btn" data-diff="medium">Средняя</button>
            <button class="btn ghost" data-diff="hard">Сложная</button>
          </div>
        </div>
      </div>

      <div class="boards">
        <div class="board-wrap" id="playerWrap">
          <div class="label-top" id="playerTop"></div>
          <div class="label-left" id="playerLeft"></div>
          <div id="playerBoard" class="board" aria-label="Поле игрока"></div>
        </div>

        <div class="board-wrap" id="enemyWrap">
          <div class="label-top" id="enemyTop"></div>
          <div class="label-left" id="enemyLeft"></div>
          <div id="enemyBoard" class="board" aria-label="Поле противника"></div>
        </div>
      </div>
    </div>

    <div class="col-right">
      <div class="panel">
        <h3>Панель кораблей</h3>
        <div id="shipList" class="ship-list"></div>

        <div class="controls" style="margin-top:10px">
          <div class="icon-btn" id="rotLeft" title="Повернуть">⟲</div>
          <div class="icon-btn" id="rotRight" title="Повернуть">⟳</div>
          <button class="btn" id="autoPlace" style="margin-left:auto">Авторасстановка</button>
        </div>
      </div>

      <div class="panel" style="margin-top:10px">
        <h3>Управление</h3>
        <div id="status" class="small">Разместите все корабли</div>
        <div style="display:flex;gap:8px;margin-top:10px">
          <button class="btn" id="startGameBtn" disabled>Старт игры</button>
          <button class="btn ghost" id="resetBtn">Сброс</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- floating rotate controls -->
<div id="rotateFloat" class="rotate-float" style="display:none">
  <div class="icon-btn" id="floatRotLeft">⟲</div>
  <div class="icon-btn" id="floatRotRight">⟳</div>
</div>

<!-- overlay end -->
<div class="overlay" id="endOverlay"><div class="panel"><h2 id="endTitle"></h2><p id="endText"></p><button class="btn" id="replayBtn">Перезапустить</button></div></div>

<div class="confetti-root" id="confettiRoot"></div>

<script>
/* ---------------- CONFIG ---------------- */
const CELL = 48; // logical cell (CSS variable)
const GAP = 3;   // grid gap (CSS variable)
const SHIP_SPEC = [
  {size:4, count:1, name:'Линкор'},
  {size:3, count:2, name:'Крейсер'},
  {size:2, count:3, name:'Эсминец'},
  {size:1, count:4, name:'Катер'}
];
const IMG = {
  ship1: 'assets/ships/ship1.png',
  ship2: 'assets/ships/ship2.png',
  ship3: 'assets/ships/ship3.png',
  ship4: 'assets/ships/ship4.png',
  hit: 'assets/hit.png',
  miss: 'assets/miss.png',
  explosion: 'assets/explosion.png',
  confetti: 'assets/confetti.png'
};

/* ---------------- STATE ---------------- */
const playerBoard = document.getElementById('playerBoard');
const enemyBoard  = document.getElementById('enemyBoard');
const playerTop   = document.getElementById('playerTop');
const playerLeft  = document.getElementById('playerLeft');
const enemyTop    = document.getElementById('enemyTop');
const enemyLeft   = document.getElementById('enemyLeft');
const shipList    = document.getElementById('shipList');
const statusEl    = document.getElementById('status');
const startGameBtn= document.getElementById('startGameBtn');
const rotateFloat = document.getElementById('rotateFloat');
const endOverlay  = document.getElementById('endOverlay');

let playerCells = [], enemyCells = [];
let playerState = Array.from({length:100}, ()=>({ship:false, hit:false, miss:false, shipId:null}));
let enemyState  = Array.from({length:100}, ()=>({ship:false, hit:false, miss:false, shipId:null}));

let shipsPool = [];      // pool definitions {id,size,placed}
let placedShips = [];    // placed ship objects {id,size,cells,orient,el,owner,sunk,origPos}
let dragging = null;     // during drag-from-pool {id,size,previewEl,originItem}
let focusedShipId = null;
let orientation = 'h';   // 'h' or 'v'
let gameStarted = false;
let playerTurn = true;

/* ---------------- HELPERS ---------------- */
const letters = 'ABCDEFGHIJ'.split('');
function idxToRC(i){ return {r: Math.floor(i/10), c: i%10}; }
function rcToIdx(r,c){ return r*10 + c; }
function isInside(r,c){ return r>=0 && r<10 && c>=0 && c<10; }

function cellRectByIndex(domCells, index){
  // returns DOMRect for cell at index
  return domCells[index].getBoundingClientRect();
}

/* ---------------- BUILD GRID ---------------- */
function buildGrid(){
  playerTop.innerHTML=''; enemyTop.innerHTML=''; playerLeft.innerHTML=''; enemyLeft.innerHTML='';
  for(let j=0;j<10;j++){ const el=document.createElement('div'); el.textContent=j+1; playerTop.appendChild(el); const el2=document.createElement('div'); el2.textContent=j+1; enemyTop.appendChild(el2); }
  for(let i=0;i<10;i++){ const el=document.createElement('div'); el.textContent=letters[i]; playerLeft.appendChild(el); const el2=document.createElement('div'); el2.textContent=letters[i]; enemyLeft.appendChild(el2); }

  playerBoard.innerHTML=''; enemyBoard.innerHTML=''; playerCells=[]; enemyCells=[];
  for(let i=0;i<100;i++){
    const pc = document.createElement('div'); pc.className='cell'; pc.dataset.index = i; playerBoard.appendChild(pc); playerCells.push(pc);
    const ec = document.createElement('div'); ec.className='cell'; ec.dataset.index = i; enemyBoard.appendChild(ec); enemyCells.push(ec);
  }
  document.getElementById('playerWrap').style.position = 'relative';
  document.getElementById('enemyWrap').style.position = 'relative';
}

/* ---------------- POOL ---------------- */
function buildPool(){
  shipList.innerHTML = '';
  shipsPool = [];
  let idc = 0;
  for(const spec of SHIP_SPEC){
    for(let k=0;k<spec.count;k++){
      const id = 's' + (idc++);
      const obj = {id, size: spec.size, placed: false, name: spec.name};
      shipsPool.push(obj);

      const item = document.createElement('div'); item.className='ship-item'; item.dataset.shipId = id;
      const prev = document.createElement('div'); prev.className='preview';
      const src = IMG['ship' + spec.size]; if(src) prev.style.backgroundImage = `url('${src}')`;
      const meta = document.createElement('div'); meta.className='meta';
      meta.innerHTML = `<div style="font-weight:700">${spec.name} (${spec.size})</div><div class="small" id="count-${id}">Статус: Не размещён</div>`;
      item.appendChild(prev); item.appendChild(meta); shipList.appendChild(item);

      // drag from pool
      item.draggable = true;
      item.addEventListener('dragstart', (e)=>{
        dragging = { id: obj.id, size: obj.size, previewSrc: src, originItem: item };
        focusedShipId = obj.id;
        item.classList.add('dragging');
        showRotateFloatAt(e.clientX, e.clientY);
        try{ e.dataTransfer.setData('text/plain', obj.id); } catch(e){}
      });
      item.addEventListener('dragend', ()=>{
        dragging = null; focusedShipId = null;
        item.classList.remove('dragging');
        hideRotateFloat();
        clearHighlights();
      });

      // click to select for tap placement
      item.addEventListener('click', ()=>{
        dragging = { id: obj.id, size: obj.size, previewSrc: src, originItem: item };
        focusedShipId = obj.id;
        document.querySelectorAll('.ship-item').forEach(x=>x.classList.remove('dragging'));
        item.classList.add('dragging');
        setStatus('Корабль выбран. Нажмите на клетку для размещения.');
      });
    }
  }
  updatePoolCounts();
}

function countRemaining(size){
  const total = SHIP_SPEC.find(s=>s.size===size).count;
  const placed = shipsPool.filter(s=>s.size===size && s.placed).length;
  return total - placed;
}

function updatePoolCounts(){
  for(const spec of SHIP_SPEC){
    let el = document.getElementById('pool-count-'+spec.size);
    if(!el){
      el = document.createElement('div'); el.id = 'pool-count-'+spec.size; el.className='small';
      document.querySelector('.panel').appendChild(el);
    }
    el.textContent = `${spec.name} (${spec.size}): ${countRemaining(spec.size)}`;
  }
}

/* ---------------- PLACEMENT RULES (no adjacent) ---------------- */
function canPlace(state, index, size, orient){
  const {r,c} = idxToRC(Number(index));
  const cells = [];
  for(let k=0;k<size;k++){
    const rr = r + (orient==='v'?k:0);
    const cc = c + (orient==='h'?k:0);
    if(!isInside(rr,cc)) return false;
    cells.push({r:rr,c:cc});
    if(state[rcToIdx(rr,cc)].ship) return false;
  }
  // adjacency check (including diagonals)
  for(const cell of cells){
    for(let dr=-1; dr<=1; dr++){
      for(let dc=-1; dc<=1; dc++){
        const rr = cell.r + dr;
        const cc = cell.c + dc;
        if(!isInside(rr,cc)) continue;
        if(state[rcToIdx(rr,cc)].ship){
          // if the found ship cell isn't part of our intended placement, block
          if(!cells.some(s=>s.r===rr && s.c===cc)) return false;
        }
      }
    }
  }
  return true;
}

/* ---------------- PLACE SHIP (with precise snapping) ---------------- */
function placeShip(state, domCells, wrapEl, index, size, orient, imgSrc, owner='player'){
  // compute r,c from index
  const {r,c} = idxToRC(Number(index));
  // use the DOM rect of the target cell to snap exactly
  const firstCellIdx = rcToIdx(r,c);
  const firstRect = domCells[firstCellIdx].getBoundingClientRect();
  const wrapRect = wrapEl.getBoundingClientRect();

  // width/height based on real cell size and count, include gaps between cells
  const cellW = firstRect.width;
  const cellH = firstRect.height;
  // compute total size including internal grid gaps
  const totalW = (orient==='h') ? (size * cellW + (size-1)*GAP) : cellW;
  const totalH = (orient==='v') ? (size * cellH + (size-1)*GAP) : cellH;

  const left = firstRect.left - wrapRect.left;
  const top  = firstRect.top  - wrapRect.top;

  // create placed ship element sized to match cells exactly
  const div = document.createElement('div');
  div.className = 'placed-ship';
  div.style.left = left + 'px';
  div.style.top  = top  + 'px';
  div.style.width = totalW + 'px';
  div.style.height = totalH + 'px';
  // place img inside to preserve aspect ratio (contain)
  if(imgSrc){
    const img = document.createElement('img');
    img.src = imgSrc;
    img.alt = 'ship';
    div.appendChild(img);
  }
  wrapEl.appendChild(div);

  // mark state
  const cellsIdx = [];
  for(let k=0;k<size;k++){
    const rr = r + (orient==='v'?k:0);
    const cc = c + (orient==='h'?k:0);
    const idx = rcToIdx(rr,cc);
    state[idx].ship = true;
    state[idx].shipId = div;
    domCells[idx].classList.add('occupied');
    cellsIdx.push(idx);
  }

  const placed = { id:'p'+(placedShips.length+1), size, cells:cellsIdx, orient, el:div, owner, sunk:false, origPos:{r,c} };
  placedShips.push(placed);

  // enable moving by pointer drag
  enablePlacedShipMoving(placed, domCells, wrapEl);

  return placed;
}

/* ---------------- HIGHLIGHTS ---------------- */
function clearHighlights(){
  playerCells.forEach(c=>c.classList.remove('valid','invalid'));
}
function highlightAt(index,size,orient){
  clearHighlights();
  for(let k=0;k<size;k++){
    const {r,c} = idxToRC(Number(index));
    const rr = r + (orient==='v'?k:0);
    const cc = c + (orient==='h'?k:0);
    if(!isInside(rr,cc)) continue;
    const idx = rcToIdx(rr,cc);
    if(canPlace(playerState, index, size, orient)) playerCells[idx].classList.add('valid'); else playerCells[idx].classList.add('invalid');
  }
}

/* ---------------- PLAYER INTERACTIONS ---------------- */
function attachPlayerHandlers(){
  playerCells.forEach(cell=>{
    cell.addEventListener('dragover', e=>{
      e.preventDefault();
      if(!dragging) return;
      highlightAt(cell.dataset.index, dragging.size, orientation);
      showRotateFloatAt(e.clientX, e.clientY);
    });
    cell.addEventListener('dragleave', ()=>{ clearHighlights(); hideRotateFloat(); });
    cell.addEventListener('drop', e=>{
      e.preventDefault();
      if(!dragging) return;
      const idx = cell.dataset.index;
      if(canPlace(playerState, idx, dragging.size, orientation)){
        placeFromPool(idx);
      } else setStatus('Нельзя разместить здесь');
      hideRotateFloat();
    });

    // tap-to-place (mobile)
    cell.addEventListener('click', ()=>{
      if(!dragging) return;
      const sp = shipsPool.find(s=>s.id===dragging.id && !s.placed);
      if(!sp) return;
      const idx = cell.dataset.index;
      if(canPlace(playerState, idx, sp.size, orientation)){
        const src = IMG['ship'+sp.size];
        placeShip(playerState, playerCells, document.getElementById('playerWrap'), idx, sp.size, orientation, src, 'player');
        sp.placed = true;
        dragging.originItem?.remove();
        dragging = null; focusedShipId = null;
        updatePoolCounts(); checkAllPlaced();
      } else {
        setStatus('Нельзя разместить здесь');
        highlightAt(idx, sp.size, orientation);
        setTimeout(()=>clearHighlights(), 450);
      }
    });

    cell.addEventListener('pointermove', (e)=>{
      if(dragging) showRotateFloatAt(e.clientX, e.clientY);
    });
  });
}

function placeFromPool(targetIndex){
  if(!dragging) return;
  const sp = shipsPool.find(s=>s.id===dragging.id && !s.placed);
  if(!sp) return;
  const src = dragging.previewSrc;
  placeShip(playerState, playerCells, document.getElementById('playerWrap'), targetIndex, sp.size, orientation, src, 'player');
  sp.placed = true;
  // remove pool item
  dragging.originItem?.remove();
  dragging = null; focusedShipId = null;
  updatePoolCounts(); checkAllPlaced();
}

/* ---------------- MOVE EXISTING SHIPS (pointer drag) ---------------- */
function enablePlacedShipMoving(placed, domCells, wrapEl){
  const el = placed.el;
  // pointer drag handlers
  let draggingPlaced = null;
  let startX = 0, startY = 0, origLeft=0, origTop=0;
  let originalCells = [...placed.cells];

  function onPointerDown(e){
    if(gameStarted) return; // cannot move after game start
    e.preventDefault();
    el.setPointerCapture(e.pointerId);
    draggingPlaced = placed;
    // record starting positions
    const rect = el.getBoundingClientRect();
    const wrapRect = wrapEl.getBoundingClientRect();
    origLeft = rect.left - wrapRect.left;
    origTop  = rect.top  - wrapRect.top;
    startX = e.clientX;
    startY = e.clientY;
    // temporarily free ship cells in state
    placed.cells.forEach(i=>{
      playerState[i].ship = false;
      playerState[i].shipId = null;
      domCells[i].classList.remove('occupied');
    });
    // store original cells to revert if needed
    originalCells = [...placed.cells];
    // visual feedback
    el.style.opacity = 0.85;
    el.style.transform = 'translateZ(0)';
    showRotateFloatAt(e.clientX, e.clientY);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);
  }

  function onPointerMove(e){
    if(!draggingPlaced) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    el.style.left = (origLeft + dx) + 'px';
    el.style.top  = (origTop  + dy) + 'px';
    showRotateFloatAt(e.clientX, e.clientY);
  }

  function onPointerUp(e){
    if(!draggingPlaced) return;
    el.releasePointerCapture(e.pointerId);
    hideRotateFloat();
    window.removeEventListener('pointermove', onPointerMove);
    window.removeEventListener('pointerup', onPointerUp);
    // compute nearest cell index to drop
    const wrapRect = wrapEl.getBoundingClientRect();
    // find top-left corner position relative to wrap
    const currentLeft = parseFloat(el.style.left || 0);
    const currentTop  = parseFloat(el.style.top  || 0);
    // determine the nearest cell index by finding which cell contains (left+1px, top+1px)
    let targetIndex = null;
    for(let i=0;i<domCells.length;i++){
      const crect = domCells[i].getBoundingClientRect();
      const relLeft = crect.left - wrapRect.left;
      const relTop = crect.top - wrapRect.top;
      // allow small threshold
      const dx = currentLeft - relLeft;
      const dy = currentTop - relTop;
      if(Math.abs(dx) < crect.width/1.5 && Math.abs(dy) < crect.height/1.5){
        targetIndex = i;
        break;
      }
    }
    // if no close cell found, try computing by coordinates
    if(targetIndex===null){
      const x = currentLeft + 2; const y = currentTop + 2;
      for(let i=0;i<domCells.length;i++){
        const crect = domCells[i].getBoundingClientRect();
        const relLeft = crect.left - wrapRect.left;
        const relTop = crect.top - wrapRect.top;
        if(x >= relLeft - 4 && x <= relLeft + crect.width + 4 && y >= relTop -4 && y <= relTop + crect.height +4){
          targetIndex = i; break;
        }
      }
    }
    // if still null, revert
    if(targetIndex === null){
      // revert visual and restore state
      placed.cells = originalCells;
      restorePlacedVisual(placed, domCells, wrapEl);
      setStatus('Размещение отменено');
      draggingPlaced = null;
      return;
    }

    // compute if can place at target with same orientation
    const cellIdx = Number(targetIndex);
    if(canPlace(playerState, cellIdx, placed.size, placed.orient)){
      // remove previous placedShips entry (we already freed state), now occupy new
      const srcImg = placed.el.querySelector('img')?.src || null;
      // remove old element and create new snapped one
      placed.el.remove();
      // create new placed ship at target
      const newPlaced = placeShip(playerState, domCells, wrapEl, cellIdx, placed.size, placed.orient, srcImg, placed.owner);
      // copy sunk state etc
      newPlaced.sunk = placed.sunk;
      // remove the old placed from placedShips (it was still present) and remove duplicate
      const idxInArray = placedShips.indexOf(placed);
      if(idxInArray !== -1) placedShips.splice(idxInArray,1); // remove old instance (it will be added by placeShip)
      // placedShips already updated inside placeShip
      setStatus('Корабль перемещён');
    } else {
      // invalid placement -> revert to original position
      placed.cells = originalCells;
      restorePlacedVisual(placed, domCells, wrapEl);
      setStatus('Нельзя разместить здесь — возвращён на место');
    }
    // cleanup
    draggingPlaced = null;
  }

  // pointerdown activates drag
  el.addEventListener('pointerdown', onPointerDown);
  // also allow click to remove (alternative)
  el.addEventListener('dblclick', ()=>{
    if(gameStarted) return;
    // remove ship and mark pool item as available
    placed.cells.forEach(i=>{
      playerState[i].ship = false;
      playerState[i].shipId = null;
      domCells[i].classList.remove('occupied');
    });
    // remove element
    el.remove();
    // mark pool: find first ship of same size that's flagged placed and unflag it
    const sp = shipsPool.find(s=>s.size===placed.size && s.placed);
    if(sp) sp.placed = false;
    // remove placed from placedShips array
    const pidx = placedShips.indexOf(placed);
    if(pidx !== -1) placedShips.splice(pidx,1);
    updatePoolCounts();
    setStatus('Корабль снят — можно разместить заново');
  });
}

function restorePlacedVisual(placed, domCells, wrapEl){
  // rebuild the visual element from placed.cells[0] (assumes placed.cells set correctly)
  const {r,c} = idxToRC(placed.cells[0]);
  const imgSrc = placed.el?.querySelector('img')?.src || IMG['ship'+placed.size];
  // remove old if exists
  try{ placed.el.remove(); }catch(e){}
  const newPlaced = placeShip(playerState, domCells, wrapEl, rcToIdx(r,c), placed.size, placed.orient, imgSrc, placed.owner);
  // copy sunk flag
  newPlaced.sunk = placed.sunk;
  // remove old instance if present
  const idx = placedShips.indexOf(placed);
  if(idx !== -1) placedShips.splice(idx,1);
}

/* ---------------- CHECK ALL PLACED ---------------- */
function checkAllPlaced(){
  const left = shipsPool.filter(s=>!s.placed).length;
  if(left===0){
    setStatus('Все корабли размещены. Нажмите Старт игры.');
    startGameBtn.disabled = false;
  } else setStatus(`Осталось разместить ${left} кораблей`);
  updatePoolCounts();
}

/* ---------------- ENEMY AUTOPLACE ---------------- */
function autoPlaceEnemy(){
  enemyState = Array.from({length:100}, ()=>({ship:false, hit:false, miss:false, shipId:null}));
  enemyCells.forEach(c=>{ c.className='cell'; c.style.backgroundImage=''; });
  const sizes = [];
  for(const s of SHIP_SPEC) for(let k=0;k<s.count;k++) sizes.push(s.size);
  for(const size of sizes){
    let placed=false, attempts=0;
    while(!placed && attempts<5000){
      attempts++;
      const idx = Math.floor(Math.random()*100);
      const orient = Math.random()<0.5 ? 'h' : 'v';
      if(canPlace(enemyState, idx, size, orient)){
        const src = IMG['ship'+size];
        placeShip(enemyState, enemyCells, document.getElementById('enemyWrap'), idx, size, orient, src, 'enemy');
        placed = true;
      }
    }
    if(!placed) console.warn('enemy place failed for size', size);
  }
  // hide enemy ship visuals (keep elements for sunk detection)
  document.getElementById('enemyWrap').querySelectorAll('.placed-ship').forEach(d=>{
    d.style.filter = 'brightness(0)';
    d.style.opacity = 0;
  });
}

/* ---------------- BATTLE ---------------- */
function startBattle(){
  if(!shipsPool.every(s=>s.placed)) { setStatus('Разместите все корабли прежде чем начать.'); return; }
  gameStarted = true; playerTurn = true;
  setStatus('Игра началась. Ваш ход.');
  startGameBtn.disabled = true;

  // bind clicks on enemy cells
  enemyCells.forEach((cell, idx)=>{
    cell.addEventListener('click', ()=>{
      if(!gameStarted) return;
      if(!playerTurn) return;
      if(enemyState[idx].hit || enemyState[idx].miss) return;
      playerShot(idx);
    });
  });
}

function playerShot(idx){
  if(enemyState[idx].ship){
    enemyState[idx].hit = true;
    showHit(enemyCells[idx]);
    setStatus('Попадание! Ваш ход продолжается.');
    checkSunkAndMark(enemyState, enemyCells, 'enemy');
    if(checkWin(enemyState)){ endGame(true); }
  } else {
    enemyState[idx].miss = true;
    showMiss(enemyCells[idx]);
    playerTurn = false;
    setStatus('Мимо — ходит бот');
    setTimeout(botTurn, 700);
  }
}

function botTurn(){
  const choices = playerCells.map((c,i)=>i).filter(i=>!playerState[i].hit && !playerState[i].miss);
  if(choices.length === 0) return;
  const idx = choices[Math.floor(Math.random()*choices.length)];
  if(playerState[idx].ship){
    playerState[idx].hit = true;
    showHit(playerCells[idx]);
    setStatus('Бот попал! Бот ходит снова.');
    checkSunkAndMark(playerState, playerCells, 'player');
    if(checkWin(playerState)){ endGame(false); return; }
    setTimeout(botTurn, 500);
  } else {
    playerState[idx].miss = true;
    showMiss(playerCells[idx]);
    playerTurn = true;
    setStatus('Бот промахнулся. Ваш ход.');
  }
}

/* ---------------- VISUALS ---------------- */
function showHit(cellEl){
  cellEl.classList.add('hit');
  if(IMG.explosion){
    const img = document.createElement('img'); img.src = IMG.explosion;
    img.style.position = 'absolute'; img.style.left=0; img.style.top=0; img.style.width='100%'; img.style.height='100%'; img.style.objectFit = 'cover';
    cellEl.appendChild(img);
    setTimeout(()=>img.remove(), 600);
  }
}

function showMiss(cellEl){
  // mark visually as miss (if not already)
  cellEl.classList.add('miss');
  const dot = document.createElement('div');
  dot.style.position='absolute';
  dot.style.left='40%'; dot.style.top='40%'; dot.style.width='20%'; dot.style.height='20%';
  dot.style.borderRadius='50%'; dot.style.background='rgba(255,255,255,0.06)';
  cellEl.appendChild(dot);
  setTimeout(()=>{ try{ dot.remove(); }catch(e){} }, 700);
}

/* ---------------- CHECK WIN ---------------- */
function checkWin(state){
  return !state.some(s=>s.ship && !s.hit);
}

/* ---------------- SINK + MARK NEIGHBOURS ---------------- */
function checkSunkAndMark(stateArr, domCells, owner){
  // get all placed ships for this owner
  const ownerShips = placedShips.filter(p => p.owner === owner);
  for(const sh of ownerShips){
    const allHit = sh.cells.every(id => stateArr[id].hit);
    if(allHit && !sh.sunk){
      sh.sunk = true;
      // reveal ship visually (for enemy we fade in)
      if(owner === 'enemy'){
        sh.el.style.opacity = 1;
        sh.el.style.filter = 'none';
      }
      // mark all neighbouring cells as misses
      for(const id of sh.cells){
        const {r,c} = idxToRC(id);
        for(let dy=-1; dy<=1; dy++){
          for(let dx=-1; dx<=1; dx++){
            const rr = r + dy; const cc = c + dx;
            if(!isInside(rr,cc)) continue;
            const nid = rcToIdx(rr,cc);
            if(!stateArr[nid].ship && !stateArr[nid].miss){
              stateArr[nid].miss = true;
              const targetCell = (owner==='enemy') ? enemyCells[nid] : playerCells[nid];
              showMiss(targetCell);
            }
          }
        }
      }
    }
  }
}

/* ---------------- END GAME ---------------- */
function endGame(playerWon){
  gameStarted = false;
  document.getElementById('endTitle').textContent = playerWon ? 'ПОБЕДА!' : 'ПОРАЖЕНИЕ';
  document.getElementById('endText').textContent = playerWon ? 'Вы победили.' : 'Вы проиграли.';
  endOverlay.classList.add('show');
  launchConfetti(playerWon ? 220 : 100, playerWon ? 7000 : 3500);
}

document.getElementById('replayBtn').addEventListener('click', ()=>{
  initGame(); endOverlay.classList.remove('show');
});

/* ---------------- FLOAT ROTATE ---------------- */
function showRotateFloatAt(x,y){ rotateFloat.style.display='flex'; rotateFloat.style.left = (x+12) + 'px'; rotateFloat.style.top = (y+12) + 'px'; }
function hideRotateFloat(){ rotateFloat.style.display='none'; }

document.getElementById('floatRotLeft').addEventListener('click', ()=>{ orientation = (orientation==='h'?'v':'h'); setStatus('Ориентация: '+orientation); });
document.getElementById('floatRotRight').addEventListener('click', ()=>{ orientation = (orientation==='h'?'v':'h'); setStatus('Ориентация: '+orientation); });

/* ---------------- CONTROLS ---------------- */
document.getElementById('rotLeft').addEventListener('click', ()=>{ orientation = (orientation==='h'?'v':'h'); setStatus('Ориентация: '+orientation); });
document.getElementById('rotRight').addEventListener('click', ()=>{ orientation = (orientation==='h'?'v':'h'); setStatus('Ориентация: '+orientation); });
document.getElementById('autoPlace').addEventListener('click', ()=>{ autoPlacePlayer(); setStatus('Авторасстановка выполнена'); });
document.getElementById('resetBtn').addEventListener('click', ()=>{ initGame(); });
startGameBtn.addEventListener('click', ()=>{ startBattle(); });
window.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='r'){ orientation = (orientation==='h'?'v':'h'); setStatus('Ориентация: '+orientation); } });

/* ---------------- AUTO PLACE PLAYER ---------------- */
function autoPlacePlayer(){
  playerState = Array.from({length:100}, ()=>({ship:false,hit:false,miss:false,shipId:null}));
  playerCells.forEach(c=>{ c.className='cell'; c.style.backgroundImage=''; });
  const sizes=[];
  for(const s of SHIP_SPEC) for(let k=0;k<s.count;k++) sizes.push(s.size);
  for(const size of sizes){
    let placed=false, attempts=0;
    while(!placed && attempts<5000){
      attempts++;
      const idx = Math.floor(Math.random()*100);
      const orient = Math.random()<0.5?'h':'v';
      if(canPlace(playerState, idx, size, orient)){
        const src = IMG['ship'+size];
        placeShip(playerState, playerCells, document.getElementById('playerWrap'), idx, size, orient, src, 'player');
        placed = true;
      }
    }
    if(!placed) console.warn('player auto place failed', size);
  }
  // remove pool UI and mark as placed
  document.querySelectorAll('.ship-item').forEach(x=>x.remove());
  shipsPool.forEach(s=>s.placed=true);
  updatePoolCounts();
  checkAllPlaced();
}

/* ---------------- CONFETTI ---------------- */
function launchConfetti(count=100, duration=4000){
  const root = document.getElementById('confettiRoot'); root.innerHTML='';
  const colors = ['#ff4d4f','#ffd666','#69c0ff','#95de64','#ff85c0','#ffd591'];
  for(let i=0;i<count;i++){
    const d = document.createElement('div'); d.style.position='fixed';
    d.style.left = Math.random()*100 + 'vw';
    d.style.top  = (-10 - Math.random()*30) + 'vh';
    const s = (6 + Math.random()*8) + 'px'; d.style.width=s; d.style.height=s;
    d.style.background = colors[Math.floor(Math.random()*colors.length)]; d.style.opacity=0.95;
    d.style.transform = `rotate(${Math.random()*360}deg)`; d.style.borderRadius='2px';
    root.appendChild(d);
    const dur = duration + Math.random()*1500;
    d.animate([{transform: d.style.transform+' translateY(0)'},{transform: d.style.transform+' translateY(' + (window.innerHeight + 300) + 'px)'}], {duration:dur, easing:'linear', iterations:1});
    setTimeout(()=>d.remove(), dur+80);
  }
}

/* ---------------- STATUS ---------------- */
function setStatus(text){ statusEl.textContent = text; }

/* ---------------- INIT ---------------- */
function initGame(){
  playerState = Array.from({length:100}, ()=>({ship:false, hit:false, miss:false, shipId:null}));
  enemyState  = Array.from({length:100}, ()=>({ship:false, hit:false, miss:false, shipId:null}));
  placedShips = []; shipsPool = []; dragging = null; focusedShipId = null;
  orientation = 'h'; gameStarted=false; playerTurn=true;
  buildGrid(); buildPool(); attachPlayerHandlers(); autoPlaceEnemy();
  updatePoolCounts(); startGameBtn.disabled = true;
  setStatus('Разместите корабли: перетащите с панели или тапните клетку (моб.).');
  hideRotateFloat();
}
initGame();

</script>
</body>
</html>
