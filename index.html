<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Морской бой — моб</title>
<style>
:root{
  --cell:35px;            /* размер клетки */
  --label-font:16px;
  --label-offset:12px;
  --accent:#1fb6ff;
  --muted:#bcd3eb;
  --bg:#041827;
  --panel:#0a2b30;
  --miss-gray:#6b6f76;
  --ship-h:35px;
  --gap:2px;              /* gap между клетками */
  --highlight-ok: #7CFF00;
  --highlight-ok-width: 3px;
  --highlight-bad: rgba(255,50,50,0.18);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#02151a,#052a33);font-family:Inter,Segoe UI,Arial;color:#eaf6ff;-webkit-tap-highlight-color:transparent}
.app{max-width:420px;margin:0 auto;padding-bottom:140px}
.header{padding:12px;display:flex;justify-content:space-between;align-items:center}
.title{font-size:18px;margin:0}
.hint{font-size:13px;color:var(--muted);margin-top:4px}

/* boards container */
.boards-container{ display:flex; flex-direction:column; align-items:center; gap:12px; padding:8px; }

/* wrapper */
.board-wrap{ width: calc((var(--cell) + var(--gap)) * 10 - var(--gap)); position:relative; padding-top: calc(var(--label-offset) + var(--label-font)); }
.coords-top{ position:absolute; left:0; top:calc(var(--label-offset)); width:100%; display:grid; grid-template-columns: repeat(10, calc(var(--cell) + var(--gap) )); grid-column-gap: var(--gap); pointer-events:none; color:var(--muted); font-weight:700; font-size:var(--label-font); text-align:center; z-index:5; padding-left:0; }
.board{ width:100%; height: calc((var(--cell) + var(--gap)) * 10 - var(--gap)); display:grid; grid-template-columns: repeat(10, var(--cell)); grid-template-rows: repeat(10, var(--cell)); gap:var(--gap); background:linear-gradient(180deg,#083241,#042e2a); border-radius:8px; overflow:visible; box-shadow:0 8px 20px rgba(0,0,0,0.6); position:relative; padding:6px; }

/* cells */
.cell{ width:var(--cell); height:var(--cell); background:linear-gradient(180deg,#08464a,#053738); border-radius:6px; border:1px solid rgba(255,255,255,0.03); position:relative; display:block; }
.cell.valid{ box-shadow: inset 0 0 0 var(--highlight-ok-width) var(--highlight-ok); }
.cell.invalid{ box-shadow: inset 0 0 0 var(--highlight-ok-width) var(--highlight-bad); }
.cell.occupied{ background-color:transparent; }

/* placed ship container and rotated image handling
   We position container exactly to cells, and inside put the original vertical PNG rotated 90deg,
   so the sprite becomes horizontal without distortion.
*/
.placed-ship{ position:absolute; pointer-events:auto; overflow:visible; z-index:20; }
.placed-ship img{ position:absolute; left:0; top:0; display:block; user-select:none; -webkit-user-drag:none; transform-origin:left top; }

/* highlight selection outline for movable ships */
.placed-ship.selected{ outline: 2px solid rgba(31,182,255,0.6); border-radius:6px; }

/* hit/miss visuals */
.cell.miss{ background: var(--miss-gray) !important; }
.hit-svg{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:30; }

/* panel bottom */
.panel-bottom{ position:fixed; left:0; right:0; bottom:0; background:linear-gradient(180deg, rgba(0,0,0,0.3), rgba(0,0,0,0.6)); padding:10px; display:flex; flex-direction:column; gap:8px; z-index:60; box-shadow:0 -6px 30px rgba(0,0,0,0.5); }
.panel-row{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
.aggregates{ display:flex; gap:8px; overflow:auto; padding-bottom:6px; }
.agg{ min-width:120px; display:flex; gap:8px; align-items:center; padding:8px; border-radius:10px; background:linear-gradient(90deg,#0e2b31,#092529); cursor:pointer; border:1px solid rgba(255,255,255,0.03); }
.preview{ width:56px; height:36px; background-size:contain; background-position:center; background-repeat:no-repeat; display:flex; align-items:center; justify-content:center; overflow:hidden; }
.preview img{ max-width:100%; max-height:100%; object-fit:contain; transform-origin:center; }

/* meta */
.meta{ color:#dff6ff; font-size:13px; }
.count{ color:var(--accent); font-weight:800; margin-left:6px; }

/* difficulty */
.diff-btn{ padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); background:transparent;color:#cfeeff; font-weight:700; font-size:13px; cursor:pointer; }
.diff-btn.active{ background:var(--accent); color:#022; border:0; }

/* controls */
.btn{ padding:8px 12px; border-radius:8px; border:0; background:var(--accent); color:#022; font-weight:800; font-size:14px; }
.btn.ghost{ background:transparent; color:#cfeeff; border:1px solid rgba(255,255,255,0.06); }

/* overlay/confetti */
.overlay{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:200; pointer-events:none; opacity:0; transition:opacity .2s; }
.overlay.show{ pointer-events:all; opacity:1; }
.box{ background:rgba(0,0,0,0.8); padding:18px; border-radius:12px; text-align:center; color:#fff; width:90%; max-width:420px; }
.confetti-root{ position:fixed; inset:0; pointer-events:none; z-index:190; }

@media(max-width:360px){ :root{ --cell:32px } }
</style>
</head>
<body>
  <div class="app">
    <header class="header">
      <div>
        <div class="title">Морской бой</div>
        <div class="hint" id="hint">Выберите корабль внизу и тапните по клетке</div>
      </div>
      <div><button id="dummy" class="btn ghost" style="background:transparent;border:0;color:var(--muted)">Главный</button></div>
    </header>

    <section class="boards-container" id="boardsContainer">
      <!-- Player board -->
      <div class="board-wrap" id="playerWrap">
        <div class="coords-top" id="coordsTop"></div>
        <div class="board" id="playerBoard"></div>
      </div>

      <!-- Enemy board (hidden until Start) -->
      <div class="board-wrap" id="enemyWrap" style="display:none;">
        <div style="position:absolute; left:0; top:calc(var(--label-offset) * -0.9); width:100%; text-align:center; color:var(--muted); font-weight:700;">Поле противника</div>
        <div class="coords-top" id="coordsTopEnemy" style="top:calc(var(--label-offset));"></div>
        <div class="board" id="enemyBoard"></div>
      </div>
    </section>
  </div>

  <!-- bottom panel -->
  <div class="panel-bottom" id="panel">
    <div class="panel-row">
      <div style="font-size:14px;color:var(--muted)">Панель кораблей</div>
      <div style="display:flex;align-items:center;gap:6px">
        <button class="diff-btn" data-diff="easy">Лёгкая</button>
        <button class="diff-btn active" data-diff="medium">Средняя</button>
        <button class="diff-btn" data-diff="hard">Сложная</button>
      </div>
    </div>

    <div class="aggregates" id="aggregates"></div>

    <div style="display:flex;justify-content:space-between;gap:8px">
      <div style="display:flex;gap:8px">
        <button id="autoBtn" class="btn">Авто</button>
        <button id="resetBtn" class="btn ghost">Сброс</button>
      </div>
      <div style="display:flex;gap:8px">
        <button id="startBtn" class="btn" disabled>Старт</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="endOverlay"><div class="box"><h2 id="endTitle"></h2><p id="endText"></p><div style="margin-top:12px"><button id="replayBtn" class="btn">Перезапустить</button></div></div></div>
  <div class="confetti-root" id="confettiRoot"></div>

<script>
/* ====== CONFIG ====== */
const CELL = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell')) || 35;
const GAP  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 2;
const SHIP_HEIGHT = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--ship-h')) || 35;

const SHIP_SPEC = [
  { size: 4, count: 1, key: 'ship1', name:'Линкор', width: 4 * CELL },
  { size: 3, count: 2, key: 'ship2', name:'Крейсер', width: 3 * CELL },
  { size: 2, count: 3, key: 'ship3', name:'Эсминец', width: 2 * CELL },
  { size: 1, count: 4, key: 'ship4', name:'Катер', width: 1 * CELL }
];

const IMG_BASE = 'assets/ships/';
const IMG = {
  ship1: IMG_BASE + 'ship11.png',
  ship2: IMG_BASE + 'ship22.png',
  ship3: IMG_BASE + 'ship33.png',
  ship4: IMG_BASE + 'ship44.png',
  hit: 'assets/hit.png',
  miss: 'assets/miss.png',
  explosion: 'assets/explosion.png'
};

/* ====== STATE ====== */
const playerBoardEl = document.getElementById('playerBoard');
const enemyBoardEl  = document.getElementById('enemyBoard');
const coordsTop = document.getElementById('coordsTop');
const coordsTopEnemy = document.getElementById('coordsTopEnemy');
const aggregatesEl = document.getElementById('aggregates');
const hintEl = document.getElementById('hint');
const startBtn = document.getElementById('startBtn');
const autoBtn = document.getElementById('autoBtn');
const resetBtn = document.getElementById('resetBtn');

let playerCells = [];
let enemyCells = [];
let playerState = []; // {ship, hit, miss, shipRef}
let enemyState = [];
let pool = {};
let placedShips = [];
let enemyShips = [];
let selectedSize = null;
let autoLocked = false;
let gameStarted = false;
let playerTurn = true;
let difficulty = 'medium';

/* for moving ships: selected placed ship id (object reference) */
let selectedPlacedShip = null;

/* ====== HELPERS ====== */
function setHint(t){ hintEl.textContent = t; }
function idxToRC(i){ return { r: Math.floor(i/10), c: i % 10 }; }
function rcToIdx(r,c){ return r*10 + c; }
function isInside(r,c){ return r>=0 && r<10 && c>=0 && c<10; }
function cellFullPx(){ return CELL + GAP; }
function widthForSize(size){ return size * CELL + (size - 1) * GAP; } // width including gaps

/* compute board padding (pixels) - used to offset placed-ship containers */
function boardPaddingPx(boardEl){
  const s = getComputedStyle(boardEl);
  return parseFloat(s.paddingLeft || s.padding || 0) || 0;
}

/* ====== BUILDERS ====== */
function buildTopNumbers(container){
  container.innerHTML = '';
  for(let i=1;i<=10;i++){
    const d = document.createElement('div');
    d.textContent = i;
    d.style.fontSize = getComputedStyle(document.documentElement).getPropertyValue('--label-font');
    container.appendChild(d);
  }
}

function buildGrid(boardEl, cellsArray, stateArray){
  boardEl.innerHTML = '';
  cellsArray.length = 0;
  stateArray.length = 0;
  for(let i=0;i<100;i++){
    const c = document.createElement('div');
    c.className = 'cell';
    c.dataset.index = i;
    boardEl.appendChild(c);
    cellsArray.push(c);
    stateArray.push({ ship:false, hit:false, miss:false, shipRef:null });
  }
}

/* ====== Panel (aggregates) ====== */
function buildPool(){
  aggregatesEl.innerHTML = '';
  pool = {};
  for(const s of SHIP_SPEC) pool[s.size] = s.count;
  for(const s of SHIP_SPEC) renderAgg(s);
}

function renderAgg(spec){
  if(pool[spec.size] <= 0) return;
  const row = document.createElement('div');
  row.className = 'agg';
  row.dataset.size = spec.size;

  const prev = document.createElement('div'); prev.className = 'preview';
  const pimg = document.createElement('img'); pimg.src = IMG[spec.key]; pimg.alt = spec.name;
  pimg.style.maxWidth='100%'; pimg.style.maxHeight='100%';
  pimg.style.transform = 'rotate(90deg)'; // show horizontal in preview
  prev.appendChild(pimg);

  const meta = document.createElement('div'); meta.className = 'meta';
  meta.innerHTML = `<div style="font-weight:700">${spec.name}</div><div class="small">Осталось: <span class="count" id="count-${spec.size}">${pool[spec.size]}</span></div>`;

  row.appendChild(prev); row.appendChild(meta);
  aggregatesEl.appendChild(row);

  row.addEventListener('click', ()=>{
    if(autoLocked) return;
    selectedSize = spec.size;
    document.querySelectorAll('.agg').forEach(x=>x.style.outline='none');
    row.style.outline = '2px solid rgba(31,182,255,0.45)';
    setHint(`Выбрано: ${spec.name} (${spec.size}). Тапните по клетке на поле.`);
    // clear any placed-ship selection
    unselectPlacedShip();
  });
}

/* ====== Placement rules: no adjacency (including diagonal).
   allow passing ignoreCells set (array of indexes) to treat them as empty (used for moving) */
function canPlace(arrState, index, size, ignoreCells = []){
  const {r,c} = idxToRC(Number(index));
  if(c + size - 1 > 9) return false;
  for(let k=0;k<size;k++){
    const rr = r;
    const cc = c + k;
    const id = rcToIdx(rr,cc);
    if(arrState[id].ship && !(ignoreCells && ignoreCells.includes(id))) return false;
  }
  for(let k=-1;k<=size;k++){
    for(let dy=-1;dy<=1;dy++){
      const rr = r + dy;
      const cc = c + k;
      if(isInside(rr,cc)){
        const id = rcToIdx(rr,cc);
        if(arrState[id].ship && !(ignoreCells && ignoreCells.includes(id))) return false;
      }
    }
  }
  return true;
}

/* ====== Place ship ======
   we compute container offset using board padding so container aligns with cells exactly
*/
function placeShip(boardCells, arrState, boardEl, index, size, owner='player', reveal=false){
  const {r,c} = idxToRC(Number(index));
  const pad = boardPaddingPx(boardEl);
  const left = c * cellFullPx() + pad;
  const top = r * cellFullPx() + pad;
  const width = widthForSize(size);

  const el = document.createElement('div');
  el.className = 'placed-ship';
  el.style.left = left + 'px';
  el.style.top  = top  + 'px';
  el.style.width = width + 'px';
  el.style.height = SHIP_HEIGHT + 'px';
  el.style.pointerEvents = 'auto';

  const spec = SHIP_SPEC.find(s=>s.size===size);
  if(spec && IMG[spec.key]){
    const img = document.createElement('img');
    img.src = IMG[spec.key];
    img.alt = spec.name;
    img.style.width = SHIP_HEIGHT + 'px';
    img.style.height = width + 'px';
    img.style.objectFit = 'contain';
    img.style.transformOrigin = 'left top';
    img.style.transform = `rotate(90deg) translateY(-100%)`;
    img.draggable = false;
    el.appendChild(img);
  }

  // allow selecting the placed-ship for moving (tap)
  if(owner === 'player'){
    el.addEventListener('click',(ev)=>{
      ev.stopPropagation();
      // select this ship for moving
      const shipObj = placedShips.find(s => s.el === el);
      if(!shipObj) return;
      if(selectedPlacedShip && selectedPlacedShip.id === shipObj.id){
        // second click toggles off
        unselectPlacedShip();
      } else {
        selectPlacedShip(shipObj);
      }
    });
    // allow long-press or double-tap later for more interactions if needed
  }

  boardEl.appendChild(el);

  const cellsIdx = [];
  for(let k=0;k<size;k++){
    const id = rcToIdx(r, c + k);
    if(owner==='player'){
      playerState[id].ship = true;
      playerState[id].shipRef = el;
      boardCells[id].classList.add('occupied');
    } else {
      enemyState[id].ship = true;
      enemyState[id].shipRef = el;
    }
    cellsIdx.push(id);
  }
  const shipObj = { id: Math.random().toString(36).slice(2,9), size, cells: cellsIdx, el, owner, sunk:false };
  if(owner==='player') placedShips.push(shipObj); else enemyShips.push(shipObj);

  if(owner==='enemy' && !reveal){
    el.style.opacity = 0; el.style.filter = 'brightness(0)';
  }
  return shipObj;
}

/* ====== Highlights preview ====== */
function clearHighlights(cells){ cells.forEach(c=>c.classList.remove('valid','invalid')); }
function highlightPreview(cells, index, size){
  clearHighlights(cells);
  const {r,c} = idxToRC(Number(index));
  for(let k=0;k<size;k++){
    const rr = r; const cc = c + k;
    if(!isInside(rr,cc)) continue;
    const id = rcToIdx(rr,cc);
    if(canPlace(playerState, index, size)) cells[id].classList.add('valid'); else cells[id].classList.add('invalid');
  }
}

/* ====== Selecting/moving placed ships (variant A: tap select -> tap new cell) ====== */
function selectPlacedShip(shipObj){
  unselectPlacedShip();
  selectedPlacedShip = shipObj;
  if(shipObj && shipObj.el) shipObj.el.classList.add('selected');
  setHint(`Перемещение: выбран корабль ${shipObj.size}. Тапните новую клетку.`);
  // visually allow placement previews that ignore this ship's own cells
  // attach a temporary listener to player cells is already present; we'll handle in click handler (moveSelectedTo)
}

function unselectPlacedShip(){
  if(selectedPlacedShip && selectedPlacedShip.el) selectedPlacedShip.el.classList.remove('selected');
  selectedPlacedShip = null;
  setHint('Выберите корабль внизу и тапните клетку или тапните размещённый корабль для перемещения.');
}

/* move selected placed ship to new index (if possible) */
function moveSelectedTo(idx){
  if(!selectedPlacedShip) return false;
  const ship = selectedPlacedShip;
  const size = ship.size;
  // compute top-left coordinate we want to move to (r,c)
  const {r,c} = idxToRC(Number(idx));
  // ensure within bounds for horizontal only (current code uses horizontal placement)
  if(c + size - 1 > 9){ setHint('Нельзя переместить: выходит за поле'); return false; }

  // create ignoreCells = current ship cells so canPlace ignores them
  const ignore = ship.cells.slice();
  if(!canPlace(playerState, idx, size, ignore)){
    setHint('Нельзя разместить здесь (столкновение или близко к другому кораблю)');
    return false;
  }

  // remove current occupancy
  ship.cells.forEach(i => {
    playerState[i].ship = false;
    playerState[i].shipRef = null;
    playerCells[i].classList.remove('occupied');
  });

  // update element position and cells
  const pad = boardPaddingPx(playerBoardEl);
  const left = c * cellFullPx() + pad;
  const top = r * cellFullPx() + pad;
  const width = widthForSize(size);
  ship.el.style.left = left + 'px';
  ship.el.style.top = top + 'px';
  ship.el.style.width = width + 'px';
  ship.el.style.height = SHIP_HEIGHT + 'px';

  const newCells = [];
  for(let k=0;k<size;k++){
    const id = rcToIdx(r, c + k);
    playerState[id].ship = true;
    playerState[id].shipRef = ship.el;
    playerCells[id].classList.add('occupied');
    newCells.push(id);
  }
  ship.cells = newCells;
  unselectPlacedShip();
  clearHighlights(playerCells);
  setHint('Корабль перемещён');
  return true;
}

/* ====== Attach player cell events (placement & moving) ====== */
function attachPlayerCellEvents(){
  playerCells.forEach(cell=>{
    cell.addEventListener('pointermove', (e)=>{
      if(selectedSize && !gameStarted && !autoLocked){
        const idx = Number(cell.dataset.index);
        highlightPreview(playerCells, idx, selectedSize);
      }
    });
    cell.addEventListener('pointerout', ()=> clearHighlights(playerCells) );
    cell.addEventListener('click', ()=>{
      if(gameStarted) return;
      if(autoLocked) return;
      const idx = Number(cell.dataset.index);
      // if there is a selected placed ship -> attempt move
      if(selectedPlacedShip){
        // try horizontal move to this idx's column
        const ok = moveSelectedTo(idx);
        if(ok){
          // after moving, update counts/enable start if finished
          if(Object.values(pool).every(v=>v===0)){ startBtn.disabled=false; setHint('Все корабли размещены — нажмите Старт'); }
        }
        return;
      }
      // normal placement from pool
      if(!selectedSize){ setHint('Выберите корабль внизу'); return; }
      if(!canPlace(playerState, idx, selectedSize)){ setHint('Нельзя разместить здесь'); return; }
      placeShip(playerCells, playerState, playerBoardEl, idx, selectedSize, 'player');
      pool[selectedSize]--; updateCounts();
      selectedSize = null;
      document.querySelectorAll('.agg').forEach(x=>x.style.outline='none');
      clearHighlights(playerCells);
      setHint('Корабль размещён');
      if(Object.values(pool).every(v=>v===0)){ startBtn.disabled=false; setHint('Все корабли размещены — нажмите Старт'); }
    });
  });

  // clicking outside any ship cancels selection
  document.addEventListener('click', (e)=>{
    const withinBoard = e.target.closest('#playerBoard');
    const clickedShipEl = e.target.closest('.placed-ship');
    if(!withinBoard && !clickedShipEl){
      unselectPlacedShip();
      document.querySelectorAll('.agg').forEach(x=>x.style.outline='none');
    }
  });
}

/* ====== Update counts ====== */
function updateCounts(){
  for(const s of SHIP_SPEC){
    const el = document.getElementById('count-'+s.size);
    if(el) el.textContent = pool[s.size];
    if(pool[s.size] <= 0){
      const row = document.querySelector(`.agg[data-size="${s.size}"]`);
      if(row) row.remove();
      if(selectedSize===s.size) selectedSize=null;
    }
  }
}

/* ====== Auto-place player ====== */
function autoPlacePlayer(){
  placedShips.forEach(s=>s.el && s.el.remove());
  placedShips = [];
  playerState = Array.from({length:100}, ()=>({ship:false,hit:false,miss:false,shipRef:null}));
  playerCells.forEach(c=> c.className='cell' );
  pool = {}; for(const s of SHIP_SPEC) pool[s.size] = s.count;
  const sizes = [];
  for(const s of SHIP_SPEC) for(let i=0;i<s.count;i++) sizes.push(s.size);
  for(const size of sizes){
    let placed=false, attempts=0;
    while(!placed && attempts<2000){
      attempts++;
      const r = Math.floor(Math.random()*10);
      const c = Math.floor(Math.random()*(10 - size + 1));
      const idx = rcToIdx(r,c);
      if(canPlace(playerState, idx, size)){
        placeShip(playerCells, playerState, playerBoardEl, idx, size, 'player');
        pool[size]--; placed=true;
      }
    }
  }
  aggregatesEl.innerHTML=''; for(const s of SHIP_SPEC) if(pool[s.size]>0) renderAgg(s);
  updateCounts();
  autoLocked = true;
  startBtn.disabled = false;
  setHint('Авторасстановка выполнена');
}

/* ====== Auto-place enemy ====== */
function autoPlaceEnemy(){
  enemyShips.forEach(s=>s.el && s.el.remove());
  enemyShips = [];
  enemyState = Array.from({length:100}, ()=>({ship:false,hit:false,miss:false,shipRef:null}));
  const sizes = [];
  for(const s of SHIP_SPEC) for(let i=0;i<s.count;i++) sizes.push(s.size);
  for(const size of sizes){
    let placed=false, attempts=0;
    while(!placed && attempts<2000){
      attempts++;
      const r = Math.floor(Math.random()*10);
      const c = Math.floor(Math.random()*(10 - size + 1));
      const idx = rcToIdx(r,c);
      if(canPlace(enemyState, idx, size)){
        placeShip(enemyCells, enemyState, enemyBoardEl, idx, size, 'enemy', false);
        placed = true;
      }
    }
  }
}

/* ====== Render hit/miss visuals ====== */
function renderHit(cellEl){
  const svgns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgns,'svg'); svg.setAttribute('viewBox','0 0 48 48'); svg.classList.add('hit-svg');
  const l1 = document.createElementNS(svgns,'line'); l1.setAttribute('x1','6'); l1.setAttribute('y1','6'); l1.setAttribute('x2','42'); l1.setAttribute('y2','42'); l1.setAttribute('stroke','white'); l1.setAttribute('stroke-width','3'); l1.setAttribute('stroke-linecap','round');
  const l2 = document.createElementNS(svgns,'line'); l2.setAttribute('x1','42'); l2.setAttribute('y1','6'); l2.setAttribute('x2','6'); l2.setAttribute('y2','42'); l2.setAttribute('stroke','white'); l2.setAttribute('stroke-width','3'); l2.setAttribute('stroke-linecap','round');
  svg.appendChild(l1); svg.appendChild(l2); cellEl.appendChild(svg);
}

function renderMiss(cellEl){
  if(cellEl.classList.contains('miss')) return;
  cellEl.classList.add('miss');
  if(IMG.miss){
    const img = new Image(); img.src = IMG.miss; img.style.position='absolute'; img.style.left=0; img.style.top=0; img.style.width='100%'; img.style.height='100%'; img.style.objectFit='contain';
    cellEl.appendChild(img);
  }
}

/* ====== Player shoots at enemy ====== */
function playerShoot(idx){
  if(!gameStarted || !playerTurn) return;
  if(enemyState[idx].hit || enemyState[idx].miss) return;
  if(enemyState[idx].ship){
    enemyState[idx].hit = true; renderHit(enemyCells[idx]);
    setHint('Попадание! Продолжайте.');
    checkSunk(enemyShips, enemyState, 'enemy');
    if(checkWinEnemy()) finish(true);
  } else {
    enemyState[idx].miss = true; renderMiss(enemyCells[idx]);
    playerTurn = false;
    setHint('Мимо. Ход бота.');
    setTimeout(botMove, 600);
  }
}

/* ====== Bot move logic ====== */
function botMove(){
  const avail = playerCells.map((c,i)=>i).filter(i=> !playerState[i].hit && !playerState[i].miss);
  if(avail.length===0) return;
  let idx;
  if(difficulty === 'easy') idx = avail[Math.floor(Math.random()*avail.length)];
  else if(difficulty === 'hard'){
    const hits = playerState.map((s,i)=> s.hit ? i : -1).filter(x=>x>=0);
    let found=-1;
    for(const h of hits){
      const {r,c} = idxToRC(h);
      const nbs = [[r+1,c],[r-1,c],[r,c+1],[r,c-1]];
      for(const [nr,nc] of nbs){
        if(isInside(nr,nc)){
          const id = rcToIdx(nr,nc);
          if(!playerState[id].hit && !playerState[id].miss){ found=id; break; }
        }
      }
      if(found>=0) break;
    }
    idx = found>=0 ? found : avail[Math.floor(Math.random()*avail.length)];
  } else idx = avail[Math.floor(Math.random()*avail.length)];

  if(playerState[idx].ship){
    playerState[idx].hit = true; renderHit(playerCells[idx]);
    setHint('Бот попал! Бот ходит снова.');
    setTimeout(botMove, 400);
    if(checkWinPlayer()) finish(false);
    // also check if any player ship sunk -> mark neighbors
    checkSunk(placedShips, playerState, 'player');
  } else {
    playerState[idx].miss = true; renderMiss(playerCells[idx]);
    playerTurn = true; setHint('Бот промахнулся. Ваш ход.');
  }
}

/* ====== Mark neighbors as misses when ship sunk ====== */
function markNeighborsAsMisses(shipObj, arrState, domCells){
  // for each ship cell, mark adjacent 3x3 cells as miss if not a ship and not already marked
  for(const id of shipObj.cells){
    const {r,c} = idxToRC(id);
    for(let dr=-1; dr<=1; dr++){
      for(let dc=-1; dc<=1; dc++){
        const nr = r + dr, nc = c + dc;
        if(!isInside(nr,nc)) continue;
        const nid = rcToIdx(nr,nc);
        // skip ship cells
        if(arrState[nid].ship) continue;
        if(!arrState[nid].miss && !arrState[nid].hit){
          arrState[nid].miss = true;
          // render miss on DOM if provided
          if(domCells && domCells[nid]) renderMiss(domCells[nid]);
        }
      }
    }
  }
}

/* ====== Sunk & Win checks ====== */
function checkSunk(list, arrState, owner){
  for(const sh of list){
    if(sh.sunk) continue;
    const allHit = sh.cells.every(i => arrState[i].hit);
    if(allHit){
      sh.sunk = true;
      if(owner==='enemy'){
        sh.el.style.opacity = 1; sh.el.style.filter=''; // reveal enemy ship
        // mark surrounding cells on enemy board as miss
        markNeighborsAsMisses(sh, arrState, enemyCells);
      } else {
        // mark surrounding cells on player board as miss
        markNeighborsAsMisses(sh, arrState, playerCells);
      }
    }
  }
}

function checkWinEnemy(){ return !enemyState.some(s=>s.ship && !s.hit); }
function checkWinPlayer(){ return !playerState.some(s=>s.ship && !s.hit); }

function finish(playerWon){
  gameStarted = false;
  const overlay = document.getElementById('endOverlay');
  document.getElementById('endTitle').textContent = playerWon ? 'ПОБЕДА!' : 'ПОРАЖЕНИЕ';
  document.getElementById('endText').textContent = playerWon ? 'Вы потопили все корабли противника.' : 'Ваши корабли потоплены.';
  overlay.classList.add('show');
  launchConfetti(playerWon?200:80, playerWon?6000:3000);
}

/* ====== Confetti simple ====== */
function launchConfetti(count=80, dur=4000){
  const root = document.getElementById('confettiRoot'); root.innerHTML='';
  for(let i=0;i<count;i++){
    const el = document.createElement('div'); el.style.position='fixed'; el.style.left=Math.random()*100+'vw'; el.style.top=(-10-Math.random()*30)+'vh';
    const s=(6+Math.random()*8)+'px'; el.style.width=s; el.style.height=s; el.style.background=['#ff4d4f','#ffd666','#69c0ff','#95de64'][Math.floor(Math.random()*4)]; el.style.opacity=0.9; el.style.zIndex=180;
    root.appendChild(el);
    const dur2 = dur + Math.random()*1200;
    el.animate([{transform:'translateY(0)'},{transform:'translateY(' + (window.innerHeight + 400) + 'px)'}],{duration:dur2,easing:'linear'});
    setTimeout(()=>el.remove(), dur2+80);
  }
}

/* ====== Controls wiring ====== */
document.getElementById('autoBtn').addEventListener('click', ()=>{ if(gameStarted) return; autoPlacePlayer(); autoPlaceEnemy(); autoLocked=true; setHint('Авторасстановка готова. Нажмите Старт.'); startBtn.disabled=false; });
document.getElementById('resetBtn').addEventListener('click', ()=>{ init(); setHint('Сброшено'); });
startBtn.addEventListener('click', ()=>{
  if(Object.values(pool).some(v=>v>0)){ setHint('Разместите все корабли прежде чем стартовать'); return; }
  document.getElementById('enemyWrap').style.display = 'block';
  gameStarted = true; playerTurn = true;
  setHint('Игра началась. Ваш ход.');
  autoPlaceEnemy();
  startBtn.disabled = true;
});

// difficulty buttons
document.querySelectorAll('.diff-btn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('.diff-btn').forEach(x=>x.classList.remove('active'));
    btn.classList.add('active');
    difficulty = btn.dataset.diff;
    setHint('Сложность: ' + difficulty);
  });
});

// enemy cell clicks -> shooting
function attachEnemyCellEvents(){
  enemyCells.forEach(cell=>{
    cell.addEventListener('click', ()=>{
      const idx = Number(cell.dataset.index);
      playerShoot(idx);
    });
  });
}

/* replay */
document.getElementById('replayBtn').addEventListener('click', ()=>{ init(); document.getElementById('endOverlay').classList.remove('show'); });

/* ====== Init everything ====== */
function init(){
  // top numbers
  buildTopNumbers(coordsTop);
  buildTopNumbers(coordsTopEnemy);

  // grids
  buildGrid(playerBoardEl, playerCells, playerState);
  buildGrid(enemyBoardEl, enemyCells, enemyState);

  // pool
  buildPool();

  // attach events for placement
  attachPlayerCellEvents();

  // attach enemy click after grid built
  attachEnemyCellEvents();

  // reset state flags
  placedShips.forEach(s=>s.el && s.el.remove()); placedShips = [];
  enemyShips.forEach(s=>s.el && s.el.remove()); enemyShips = [];
  playerState = Array.from({length:100}, ()=>({ship:false,hit:false,miss:false,shipRef:null}));
  enemyState  = Array.from({length:100}, ()=>({ship:false,hit:false,miss:false,shipRef:null}));
  pool = {}; for(const s of SHIP_SPEC) pool[s.size] = s.count;
  updateCounts();
  autoLocked=false; gameStarted=false; playerTurn=true; selectedSize=null;
  selectedPlacedShip = null;
  document.getElementById('enemyWrap').style.display = 'none';
  startBtn.disabled = true;
  setHint('Выберите корабль внизу и тапните клетку или нажмите Авто.');
}

init();

</script>
</body>
</html>
